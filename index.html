<style>
    /* ... existing styles ... */
    
    .word-card { 
        background: var(--card-base); border-radius: 25px;
        display: flex; flex-direction: column; align-items: center; justify-content: center;
        font-weight: 800; text-transform: uppercase; cursor: pointer; 
        user-select: none; text-align: center; padding: 5px; transition: background 0.15s ease;
        overflow: hidden;
    }

    .word-text { font-size: 1.0rem; color: #000; margin-bottom: 2px; }

    /* The Phonetic and Definition styling */
    .def-container { 
        font-size: 0.65rem; 
        text-transform: none; 
        font-weight: 500; 
        color: #222; 
        line-height: 1.1;
        display: none; /* Hidden by default */
        padding: 0 8px;
    }
    
    .phonetic-text {
        font-style: italic;
        color: #444;
        display: block;
        margin-bottom: 2px;
    }
</style>

<script>
    // 1. THE DICTIONARY BRAIN
    // Add every word from your JSON here to ensure they have definitions.
    const dictionary = {
        "APPLE": { phon: "/ˈæp.əl/", def: "A round fruit with red or green skin." },
        "DATE": { phon: "/deɪt/", def: "A sweet brown fruit or a specific day." },
        "LIME": { phon: "/laɪm/", def: "A small, green, sour citrus fruit." },
        "BARK": { phon: "/bɑːrk/", def: "Outer covering of a tree or a dog's cry." },
        "PEN": { phon: "/pen/", def: "An instrument for writing with ink." },
        "FOLD": { phon: "/foʊld/", def: "To bend something over on itself." },
        "SHIFT": { phon: "/ʃɪft/", def: "To move or change position." },
        "ENTER": { phon: "/ˈen.tər/", def: "To come or go into a place." },
        "STAPLE": { phon: "/ˈsteɪ.pəl/", def: "A small wire fastner." },
        "SOW": { phon: "/soʊ/", def: "To plant seed by scattering." }
        // Add more as needed!
    };

    let gameData = [], currentWords = [], selectedWords = [], mistakes = 4, masterBank = null;

    async function initGame() {
        try {
            const response = await fetch('master_category_bank.json');
            masterBank = await response.json();
            loadNewPuzzle();
        } catch (e) { console.error("Error loading JSON", e); }
    }

    function loadNewPuzzle() {
        const batches = Object.keys(masterBank.batches);
        const randomBatchKey = batches[Math.floor(Math.random() * batches.length)];
        let potentialCategories = masterBank.batches[randomBatchKey];
        
        gameData = potentialCategories.length > 4 ? potentialCategories.sort(() => 0.5 - Math.random()).slice(0, 4) : potentialCategories;
        
        mistakes = 4;
        selectedWords = [];
        document.getElementById('solved-container').innerHTML = '';
        document.querySelectorAll('.circle').forEach(c => c.classList.remove('spent'));
        document.getElementById('submit-btn').disabled = true;

        currentWords = [];
        gameData.forEach(cat => cat.words.forEach(word => currentWords.push({ text: word, catId: cat.id, color: cat.color })));
        shuffleWords();
    }

    function renderGrid() {
        const gridEl = document.getElementById('grid');
        gridEl.innerHTML = '';
        currentWords.forEach(wordObj => {
            const div = document.createElement('div');
            div.className = 'word-card';
            if (selectedWords.find(sw => sw.text === wordObj.text)) div.classList.add('selected');
            
            // Get data from dictionary or use placeholders
            const info = dictionary[wordObj.text] || { phon: "", def: "Definition missing." };
            
            div.innerHTML = `
                <div class="word-text">${wordObj.text}</div>
                <div class="def-container" id="def-${wordObj.text}">
                    <span class="phonetic-text">${info.phon}</span>
                    ${info.def}
                </div>
            `;
            div.onclick = () => toggleSelect(div, wordObj);
            gridEl.appendChild(div);
        });
    }

    function toggleSelect(el, wordObj) {
        if (el.classList.contains('selected')) {
            el.classList.remove('selected');
            selectedWords = selectedWords.filter(w => w.text !== wordObj.text);
            // Hide definition when deselected
            const def = document.getElementById(`def-${wordObj.text}`);
            if(def) def.style.display = 'none';
        } else if (selectedWords.length < 4) {
            el.classList.add('selected');
            selectedWords.push(wordObj);
        }
        document.getElementById('submit-btn').disabled = selectedWords.length !== 4;
    }

    function shuffleWords() {
        currentWords.sort(() => Math.random() - 0.5);
        renderGrid();
    }

    document.getElementById('shuffle-btn').onclick = shuffleWords;
    document.getElementById('new-game-btn').onclick = loadNewPuzzle;
    
    // THE DEFINITION BUTTON LOGIC
    document.getElementById('def-btn').onclick = () => {
        selectedWords.forEach(w => {
            const def = document.getElementById(`def-${w.text}`);
            if (def) {
                // Toggle visibility
                def.style.display = (def.style.display === 'block') ? 'none' : 'block';
            }
        });
    };

    document.getElementById('submit-btn').onclick = () => {
        const firstId = selectedWords[0].catId;
        const isMatch = selectedWords.every(w => w.catId === firstId);
        if (isMatch) handleCorrect(firstId);
        else handleWrong();
    };

    function handleCorrect(catId) {
        const category = gameData.find(c => c.id === catId);
        currentWords = currentWords.filter(w => w.catId !== catId);
        const row = document.createElement('div');
        row.className = 'solved-row';
        const colorMap = { "Seed": "--seed", "Red Herring": "--red-herring", "Tricky": "--tricky", "Expert": "--expert" };
        row.style.backgroundColor = `var(${colorMap[category.color] || "--card-base"})`;
        row.innerHTML = `<div>${category.name}</div><div style="font-weight:normal; font-size: 0.9rem">${category.words.join(', ')}</div>`;
        document.getElementById('solved-container').appendChild(row);
        selectedWords = [];
        document.getElementById('submit-btn').disabled = true;
        renderGrid();
    }

    function handleWrong() {
        mistakes--;
        const circles = document.querySelectorAll('.circle');
        if (circles[mistakes]) circles[mistakes].classList.add('spent');
        const grid = document.getElementById('grid');
        grid.classList.add('shake');
        setTimeout(() => grid.classList.remove('shake'), 500);
        if (mistakes === 0) { setTimeout(() => { alert("Game Over!"); loadNewPuzzle(); }, 600); }
    }

    initGame();
</script>